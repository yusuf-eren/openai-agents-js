import { Agent } from './agent';
import { AgentOutputSchema } from './agent-outputs';
import {
  InputGuardrailTripwireTriggered,
  MaxTurnsExceeded,
} from './exceptions';
import { InputGuardrailResult, OutputGuardrailResult } from './guardrails';
import {
  ItemHelpers,
  ModelResponse,
  RunItem,
  TResponseInputItem,
} from './items';
import { logger } from './logger';
import { StreamEvent } from './stream-events';
import { Trace } from './tracing/traces';
import {
  prettyPrintResult,
  prettyPrintRunResultStreaming,
} from './utils/pretty-print';
import { QueueCompleteSentinel } from './_run-impl';
import { RunImpl } from './_run-impl';
import { SingleStepResult } from './_run-impl';
import { AgentUpdatedStreamEvent } from './stream-events';

/**
 * Base class for run results
 */
export abstract class RunResultBase {
  /**
   * The original input items i.e. the items before run() was called. This may be a mutated
   * version of the input, if there are handoff input filters that mutate the input.
   */
  input: string | TResponseInputItem[];

  /**
   * The new items generated during the agent run. These include things like new messages, tool
   * calls and their outputs, etc.
   */
  newItems: RunItem[];

  /**
   * The raw LLM responses generated by the model during the agent run.
   */
  rawResponses: ModelResponse[];

  /**
   * The output of the last agent.
   */
  finalOutput: any;

  /**
   * Guardrail results for the input messages.
   */
  inputGuardrailResults: InputGuardrailResult[];

  /**
   * Guardrail results for the final output of the agent.
   */
  outputGuardrailResults: OutputGuardrailResult[];

  constructor(
    input: string | TResponseInputItem[],
    newItems: RunItem[],
    rawResponses: ModelResponse[],
    finalOutput: any,
    inputGuardrailResults: InputGuardrailResult[],
    outputGuardrailResults: OutputGuardrailResult[]
  ) {
    this.input = input;
    this.newItems = newItems;
    this.rawResponses = rawResponses;
    this.finalOutput = finalOutput;
    this.inputGuardrailResults = inputGuardrailResults;
    this.outputGuardrailResults = outputGuardrailResults;
  }

  /**
   * The last agent that was run.
   */
  abstract get lastAgent(): Agent<any>;

  /**
   * A convenience method to cast the final output to a specific type. By default, the cast
   * is only for the typechecker. If you set `raiseIfIncorrectType` to true, we'll raise a
   * TypeError if the final output is not of the given type.
   *
   * @param cls The type to cast the final output to.
   * @param raiseIfIncorrectType If true, we'll raise a TypeError if the final output is not of
   * the given type.
   * @returns The final output casted to the given type.
   */
  finalOutputAs<T>(
    cls: new (...args: any[]) => T,
    raiseIfIncorrectType: boolean = false
  ): T {
    if (raiseIfIncorrectType && !(this.finalOutput instanceof cls)) {
      throw new TypeError(`Final output is not of type ${cls.name}`);
    }

    return this.finalOutput as T;
  }

  /**
   * Creates a new input list, merging the original input with all the new items generated.
   */
  toInputList(): TResponseInputItem[] {
    const originalItems: TResponseInputItem[] = ItemHelpers.inputToNewInputList(
      this.input
    );
    const newItems = this.newItems.map((item) => item.toInputItem());

    return [...originalItems, ...newItems];
  }

  get lastResponseId(): string | null {
    return this.rawResponses[this.rawResponses.length - 1]?.response_id ?? null;
  }
}

/**
 * The result of a completed agent run
 */
export class RunResult extends RunResultBase {
  private _lastAgent: Agent<any>;

  constructor(
    input: string | TResponseInputItem[],
    newItems: RunItem[],
    rawResponses: ModelResponse[],
    finalOutput: any,
    inputGuardrailResults: InputGuardrailResult[],
    outputGuardrailResults: OutputGuardrailResult[],
    lastAgent: Agent<any>
  ) {
    super(
      input,
      newItems,
      rawResponses,
      finalOutput,
      inputGuardrailResults,
      outputGuardrailResults
    );
    this._lastAgent = lastAgent;
  }

  /**
   * The last agent that was run.
   */
  get lastAgent(): Agent<any> {
    return this._lastAgent;
  }

  toString(): string {
    return prettyPrintResult(this);
  }
}

/**
 * The result of an agent run in streaming mode. You can use the `streamEvents` method to
 * receive semantic events as they are generated.
 *
 * The streaming method will raise:
 * - A MaxTurnsExceeded exception if the agent exceeds the max_turns limit.
 * - A GuardrailTripwireTriggered exception if a guardrail is tripped.
 */
export class RunResultStreaming extends RunResultBase {
  /**
   * The current agent that is running.
   */
  currentAgent: Agent<any>;

  /**
   * The current turn number.
   */
  currentTurn: number;

  /**
   * The maximum number of turns the agent can run for.
   */
  maxTurns: number;

  /**
   * Whether the agent has finished running.
   */
  isComplete: boolean = false;

  _current_agent_output_schema?: AgentOutputSchema | null;
  _trace: Trace | null;
  _event_queue: AsyncQueue<StreamEvent | QueueCompleteSentinel>;
  _input_guardrail_queue: AsyncQueue<
    InputGuardrailResult | QueueCompleteSentinel
  >;
  _run_impl_task: Promise<any> | null = null;
  _input_guardrails_task?: Promise<void> | null = null;
  _output_guardrails_task?: Promise<OutputGuardrailResult[]> | null = null;
  _stored_exception: Error | null = null;

  constructor(
    input: string | TResponseInputItem[],
    newItems: RunItem[],
    rawResponses: ModelResponse[],
    finalOutput: any,
    inputGuardrailResults: InputGuardrailResult[],
    outputGuardrailResults: OutputGuardrailResult[],
    currentAgent: Agent<any>,
    currentTurn: number,
    maxTurns: number,
    currentAgentOutputSchema: AgentOutputSchema | null,
    trace: Trace | null
  ) {
    super(
      input,
      newItems,
      rawResponses,
      finalOutput,
      inputGuardrailResults,
      outputGuardrailResults
    );
    this.currentAgent = currentAgent;
    this.currentTurn = currentTurn;
    this.maxTurns = maxTurns;
    this._current_agent_output_schema = currentAgentOutputSchema;
    this._trace = trace;
    this._event_queue = new AsyncQueue<StreamEvent | QueueCompleteSentinel>();
    this._input_guardrail_queue = new AsyncQueue<
      InputGuardrailResult | QueueCompleteSentinel
    >();
  }

  /**
   * The last agent that was run. Updates as the agent run progresses, so the true last agent
   * is only available after the agent run is complete.
   */
  get lastAgent(): Agent<any> {
    return this.currentAgent;
  }

  /**
   * Stream deltas for new items as they are generated. We're using the types from the
   * OpenAI Responses API, so these are semantic events: each event has a `type` field that
   * describes the type of the event, along with the data for that event.
   *
   * This will raise:
   * - A MaxTurnsExceeded exception if the agent exceeds the max_turns limit.
   * - A GuardrailTripwireTriggered exception if a guardrail is tripped.
   */
  async *streamEvents(): AsyncGenerator<StreamEvent> {
    while (true) {
      this._checkErrors();
      if (this._stored_exception) {
        logger.debug('Breaking due to stored exception');
        this.isComplete = true;
        break;
      }

      if (this.isComplete && this._event_queue.isEmpty()) {
        break;
      }

      try {
        const item = await this._event_queue.get();
        this._event_queue.taskDone();

        if (item instanceof QueueCompleteSentinel) {
          // Check for errors, in case the queue was completed due to an exception
          this._checkErrors();
          break;
        }

        yield item as StreamEvent;
      } catch (error) {
        if (error instanceof Error && error.name === 'AbortError') {
          break;
        }
        throw error;
      }
    }

    if (this._trace) {
      this._trace.finish(true);
    }

    this._cleanupTasks();

    if (this._stored_exception) {
      throw this._stored_exception;
    }
  }

  private _checkErrors(): void {
    if (this.currentTurn > this.maxTurns) {
      this._stored_exception = new MaxTurnsExceeded(
        `Max turns (${this.maxTurns}) exceeded`
      );
    }

    // Fetch all the completed guardrail results from the queue and raise if needed
    while (!this._input_guardrail_queue.isEmpty()) {
      const guardrailResult = this._input_guardrail_queue.getNonBlocking();
      if (
        guardrailResult &&
        !(guardrailResult instanceof QueueCompleteSentinel) &&
        guardrailResult.output.tripwire_triggered
      ) {
        this._stored_exception = new InputGuardrailTripwireTriggered(
          guardrailResult
        );
      }
    }

    // Check the tasks for any exceptions
    // Note: In a real implementation, you would need to handle task exceptions properly
    // This is a simplification since JavaScript promises work differently from Python tasks
  }

  private _cleanupTasks(): void {
    // In a real implementation, you would need to cancel the tasks
    // This is a simplification since JavaScript promises don't have direct cancellation
  }

  toString(): string {
    return prettyPrintRunResultStreaming(this);
  }

  /**
   * Add an input guardrail result to the queue
   */
  async addInputGuardrailResult(result: InputGuardrailResult): Promise<void> {
    this.inputGuardrailResults.push(result);
    this._input_guardrail_queue.put_nowait(result);
  }

  /**
   * Add a step result to the event queue
   */
  async addStepResult(stepResult: SingleStepResult): Promise<void> {
    this.newItems.push(...stepResult.newStepItems);
    this.rawResponses.push(stepResult.modelResponse);
    this._event_queue.put_nowait({
      type: 'step',
      stepResult,
    });
  }

  /**
   * Complete the streaming by adding a sentinel to the queue
   */
  async complete(): Promise<void> {
    this.isComplete = true;
    this._event_queue.put_nowait(QueueCompleteSentinel);
  }

  /**
   * Update the current agent and emit an event
   */
  async updateAgent(agent: Agent<any>): Promise<void> {
    this.currentAgent = agent;
    this._event_queue.put_nowait({
      type: 'agent_updated',
      agent,
    });
  }

  /**
   * Set an error and complete the streaming
   */
  async setError(error: Error): Promise<void> {
    this._stored_exception = error;
    await this.complete();
  }
}

/**
 * Simple async queue implementation to mimic Python's asyncio.Queue
 */
export class AsyncQueue<T> {
  private _queue: T[] = [];
  private _waiters: Array<(value: T) => void> = [];
  private _tasksInProgress: number = 0;

  async get(): Promise<T> {
    if (this._queue.length > 0) {
      this._tasksInProgress++;
      return this._queue.shift()!;
    }

    return new Promise<T>((resolve) => {
      this._waiters.push(resolve);

      // âœ… Immediately fulfill if queue was already filled via put_nowait
      if (this._queue.length > 0) {
        const item = this._queue.shift()!;
        this._tasksInProgress++;
        const waiter = this._waiters.shift()!;
        waiter(item);
      }
    });
  }

  getNonBlocking(): T | null {
    if (this._queue.length > 0) {
      this._tasksInProgress++;
      return this._queue.shift()!;
    }
    return null;
  }

  put(item: T): void {
    if (this._waiters.length > 0) {
      const waiter = this._waiters.shift()!;
      this._tasksInProgress++;
      waiter(item);
    } else {
      this._queue.push(item);
    }
  }

  put_nowait(item: T): void {
    if (this._waiters.length > 0) {
      const waiter = this._waiters.shift()!;
      this._tasksInProgress++;
      waiter(item); // resolve immediately
    } else {
      this._queue.push(item);
    }
  }

  taskDone(): void {
    this._tasksInProgress--;
  }

  isEmpty(): boolean {
    return this._queue.length === 0;
  }
}
