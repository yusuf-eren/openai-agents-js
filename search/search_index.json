{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OpenAI Agents SDK","text":"<p>The OpenAI Agents SDK enables you to build agentic AI apps in a lightweight, easy-to-use package with very few abstractions. It's a production-ready upgrade of our previous experimentation for agents, Swarm. The Agents SDK has a very small set of primitives:</p> <ul> <li>Agents, which are LLMs equipped with instructions and tools</li> <li>Handoffs, which allow agents to delegate to other agents for specific tasks</li> <li>Guardrails, which enable the inputs to agents to be validated</li> </ul> <p>In combination with JavaScript/TypeScript, these primitives are powerful enough to express complex relationships between tools and agents, and allow you to build real-world applications without a steep learning curve. In addition, the SDK comes with built-in tracing that lets you visualize and debug your agentic flows, as well as evaluate them and even fine-tune models for your application.</p>"},{"location":"#why-use-the-agents-sdk","title":"Why use the Agents SDK","text":"<p>The SDK has two driving design principles:</p> <ol> <li>Enough features to be worth using, but few enough primitives to make it quick to learn.</li> <li>Works great out of the box, but you can customize exactly what happens.</li> </ol> <p>Here are the main features of the SDK:</p> <ul> <li>Agent loop: Built-in agent loop that handles calling tools, sending results to the LLM, and looping until the LLM is done.</li> <li>TypeScript-first: Use built-in language features to orchestrate and chain agents, rather than needing to learn new abstractions.</li> <li>Handoffs: A powerful feature to coordinate and delegate between multiple agents.</li> <li>Guardrails: Run input validations and checks in parallel to your agents, breaking early if the checks fail.</li> <li>Function tools: Turn any JavaScript/TypeScript function into a tool, with automatic schema generation and validation.</li> <li>Tracing: Built-in tracing that lets you visualize, debug and monitor your workflows, as well as use the OpenAI suite of evaluation, fine-tuning and distillation tools.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>npm install openai-agents-js\n</code></pre>"},{"location":"#hello-world-example","title":"Hello world example","text":"<pre><code>import { Agent, Runner } from 'openai-agents-js';\n\nasync function main() {\n  const agent = new Agent({\n    name: 'Assistant',\n    instructions: 'You only respond in haikus.',\n  });\n\n  const result = await Runner.run(agent, 'Tell me about recursion in programming.');\n  console.log(result.finalOutput);\n  // Function calls itself,\n  // Looping in smaller pieces,\n  // Endless by design.\n}\n\nmain();\n</code></pre> <p>(If running this, ensure you set the <code>OPENAI_API_KEY</code> environment variable)</p> <pre><code>export OPENAI_API_KEY=sk-...\n</code></pre>"},{"location":"agents/","title":"Agents","text":"<p>Agents are the core building blocks of the OpenAI Agents SDK. They are LLMs equipped with instructions and tools that can perform tasks and interact with the world.</p>"},{"location":"agents/#creating-agents","title":"Creating Agents","text":"<pre><code>import { Agent } from 'openai-agents';\n\nconst agent = new Agent({\n  name: \"Assistant\",\n  instructions: \"You are a helpful assistant\",\n  model: \"gpt-4-turbo-preview\", // Optional: specify the model to use\n  temperature: 0.7, // Optional: control randomness\n  maxTokens: 1000, // Optional: limit response length\n});\n</code></pre>"},{"location":"agents/#agent-configuration","title":"Agent Configuration","text":""},{"location":"agents/#required-parameters","title":"Required Parameters","text":"<ul> <li><code>name</code>: A unique identifier for the agent</li> <li><code>instructions</code>: The system prompt that defines the agent's behavior and capabilities</li> </ul>"},{"location":"agents/#optional-parameters","title":"Optional Parameters","text":"<ul> <li><code>model</code>: The OpenAI model to use (default: \"gpt-4-turbo-preview\")</li> <li><code>temperature</code>: Controls randomness (0.0 to 1.0)</li> <li><code>maxTokens</code>: Maximum number of tokens in the response</li> <li><code>tools</code>: Array of tools the agent can use</li> <li><code>handoffs</code>: Array of other agents this agent can delegate to</li> <li><code>guardrails</code>: Array of validation rules for inputs</li> </ul>"},{"location":"agents/#agent-lifecycle","title":"Agent Lifecycle","text":"<ol> <li>Initialization: The agent is created with its configuration</li> <li>Tool Selection: The agent decides which tools to use based on the task</li> <li>Execution: The agent executes the selected tools</li> <li>Response: The agent processes the tool results and generates a response</li> </ol>"},{"location":"agents/#example-multi-tool-agent","title":"Example: Multi-Tool Agent","text":"<pre><code>import { Agent, Tool } from 'openai-agents';\n\n// Define tools\nconst weatherTool = new Tool({\n  name: \"get_weather\",\n  description: \"Get current weather for a location\",\n  function: async (location: string) =&gt; {\n    // Implementation here\n  }\n});\n\nconst calendarTool = new Tool({\n  name: \"check_calendar\",\n  description: \"Check calendar for events\",\n  function: async (date: string) =&gt; {\n    // Implementation here\n  }\n});\n\n// Create agent with multiple tools\nconst assistant = new Agent({\n  name: \"PersonalAssistant\",\n  instructions: `You are a personal assistant that can help with weather and calendar information.\n                 Use the weather tool to check current conditions and the calendar tool to check schedules.`,\n  tools: [weatherTool, calendarTool]\n});\n</code></pre>"},{"location":"agents/#best-practices","title":"Best Practices","text":"<ol> <li>Clear Instructions: Write specific, detailed instructions for your agent</li> <li>Tool Selection: Only include tools that are relevant to the agent's purpose</li> <li>Error Handling: Implement proper error handling in tool functions</li> <li>Token Management: Be mindful of token limits when designing instructions</li> <li>Testing: Test agents with various inputs to ensure reliable behavior</li> </ol>"},{"location":"agents/#advanced-features","title":"Advanced Features","text":""},{"location":"agents/#model-context-protocol-mcp","title":"Model Context Protocol (MCP)","text":"<p>Agents can use the Model Context Protocol to maintain state and context across interactions:</p> <pre><code>const agent = new Agent({\n  name: \"ContextualAssistant\",\n  instructions: \"You are an assistant that maintains context across conversations\",\n  useMCP: true\n});\n</code></pre>"},{"location":"agents/#streaming-responses","title":"Streaming Responses","text":"<p>Get real-time updates as the agent processes:</p> <pre><code>const result = await Runner.run(agent, \"What is the weather?\", {\n  stream: true,\n  onToken: (token) =&gt; {\n    console.log(token);\n  }\n});\n</code></pre>"},{"location":"agents/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Tools in detail</li> <li>Explore Handoffs for complex workflows</li> <li>Set up Tracing for debugging</li> <li>Read about Guardrails for input validation </li> </ul>"},{"location":"guardrails/","title":"Guardrails","text":"<p>Guardrails help ensure your agents operate safely and reliably by validating inputs, enforcing constraints, and preventing unwanted behaviors.</p>"},{"location":"guardrails/#basic-guardrails","title":"Basic Guardrails","text":"<pre><code>import { Agent, Runner, Guardrail } from 'openai-agents';\n\n// Create a guardrail\nconst inputGuardrail = new Guardrail({\n  name: \"input-validator\",\n  validate: (input: string) =&gt; {\n    if (input.length &gt; 1000) {\n      throw new Error(\"Input too long\");\n    }\n    if (input.includes(\"password\")) {\n      throw new Error(\"Sensitive information detected\");\n    }\n    return true;\n  }\n});\n\n// Create an agent with guardrails\nconst agent = new Agent({\n  name: \"GuardedAgent\",\n  instructions: \"You are a helpful assistant\",\n  guardrails: [inputGuardrail]\n});\n\n// Run the agent with guardrails\nconst result = await Runner.run(agent, \"What is the weather?\");\n</code></pre>"},{"location":"guardrails/#guardrail-types","title":"Guardrail Types","text":""},{"location":"guardrails/#1-input-validation","title":"1. Input Validation","text":"<p>Validate user inputs:</p> <pre><code>const inputGuardrail = new Guardrail({\n  name: \"input-validator\",\n  validate: (input: string) =&gt; {\n    // Check input length\n    if (input.length &gt; 1000) {\n      throw new Error(\"Input too long\");\n    }\n\n    // Check for sensitive information\n    if (input.includes(\"password\") || input.includes(\"token\")) {\n      throw new Error(\"Sensitive information detected\");\n    }\n\n    // Check for harmful content\n    if (input.includes(\"hack\") || input.includes(\"exploit\")) {\n      throw new Error(\"Potentially harmful content detected\");\n    }\n\n    return true;\n  }\n});\n</code></pre>"},{"location":"guardrails/#2-output-validation","title":"2. Output Validation","text":"<p>Validate agent outputs:</p> <pre><code>const outputGuardrail = new Guardrail({\n  name: \"output-validator\",\n  validate: (output: string) =&gt; {\n    // Check output length\n    if (output.length &gt; 5000) {\n      throw new Error(\"Output too long\");\n    }\n\n    // Check for code injection\n    if (output.includes(\"&lt;script&gt;\") || output.includes(\"eval(\")) {\n      throw new Error(\"Potentially harmful code detected\");\n    }\n\n    return true;\n  }\n});\n</code></pre>"},{"location":"guardrails/#3-tool-validation","title":"3. Tool Validation","text":"<p>Validate tool usage:</p> <pre><code>const toolGuardrail = new Guardrail({\n  name: \"tool-validator\",\n  validate: (tool: Tool, args: any[]) =&gt; {\n    // Check tool usage frequency\n    if (tool.usageCount &gt; 100) {\n      throw new Error(\"Tool usage limit exceeded\");\n    }\n\n    // Check tool arguments\n    if (args.some(arg =&gt; typeof arg === \"string\" &amp;&amp; arg.length &gt; 1000)) {\n      throw new Error(\"Tool argument too long\");\n    }\n\n    return true;\n  }\n});\n</code></pre>"},{"location":"guardrails/#advanced-features","title":"Advanced Features","text":""},{"location":"guardrails/#custom-validators","title":"Custom Validators","text":"<p>Create custom validation logic:</p> <pre><code>const customGuardrail = new Guardrail({\n  name: \"custom-validator\",\n  validate: async (input: any) =&gt; {\n    // Custom validation logic\n    const result = await validateWithExternalService(input);\n    if (!result.valid) {\n      throw new Error(result.reason);\n    }\n    return true;\n  }\n});\n</code></pre>"},{"location":"guardrails/#chain-validators","title":"Chain Validators","text":"<p>Combine multiple validators:</p> <pre><code>const chainGuardrail = new Guardrail({\n  name: \"chain-validator\",\n  validators: [\n    inputGuardrail,\n    outputGuardrail,\n    toolGuardrail\n  ]\n});\n</code></pre>"},{"location":"guardrails/#conditional-validation","title":"Conditional Validation","text":"<p>Validate based on conditions:</p> <pre><code>const conditionalGuardrail = new Guardrail({\n  name: \"conditional-validator\",\n  validate: (input: any, context: any) =&gt; {\n    if (context.userType === \"admin\") {\n      return true; // Skip validation for admins\n    }\n    return inputGuardrail.validate(input);\n  }\n});\n</code></pre>"},{"location":"guardrails/#best-practices","title":"Best Practices","text":"<ol> <li>Clear Error Messages: Provide helpful error messages</li> <li>Performance: Keep validation logic efficient</li> <li>Security: Validate all inputs and outputs</li> <li>Testing: Test guardrails thoroughly</li> <li>Monitoring: Monitor guardrail effectiveness</li> </ol>"},{"location":"guardrails/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Agents in detail</li> <li>Explore Tools for agent capabilities</li> <li>Understand Handoffs for complex workflows</li> <li>Set up Tracing for debugging </li> </ul>"},{"location":"handoffs/","title":"Handoffs","text":"<p>Handoffs allow agents to delegate tasks to other agents when they need specialized capabilities or when a task is better handled by a different agent.</p>"},{"location":"handoffs/#basic-handoff","title":"Basic Handoff","text":"<pre><code>import { Agent, Runner } from 'openai-agents';\n\n// Create specialized agents\nconst mathAgent = new Agent({\n  name: \"MathExpert\",\n  instructions: \"You are a math expert that can solve complex mathematical problems.\"\n});\n\nconst codingAgent = new Agent({\n  name: \"CodeExpert\",\n  instructions: \"You are a programming expert that can help with coding tasks.\"\n});\n\n// Create main agent with handoff capabilities\nconst mainAgent = new Agent({\n  name: \"Coordinator\",\n  instructions: \"You are a coordinator that can delegate tasks to specialized agents.\",\n  handoffs: [mathAgent, codingAgent]\n});\n\n// Run the main agent\nconst result = await Runner.run(mainAgent, \"Solve the equation: 2x + 5 = 15\");\n</code></pre>"},{"location":"handoffs/#handoff-configuration","title":"Handoff Configuration","text":""},{"location":"handoffs/#required-parameters","title":"Required Parameters","text":"<ul> <li><code>name</code>: A unique identifier for the agent</li> <li><code>instructions</code>: The system prompt that defines when to use this agent</li> <li><code>handoffs</code>: Array of agents that can be delegated to</li> </ul>"},{"location":"handoffs/#optional-parameters","title":"Optional Parameters","text":"<ul> <li><code>handoffRules</code>: Rules for when to use each agent</li> <li><code>handoffPrompt</code>: Custom prompt for the handoff process</li> <li><code>handoffTimeout</code>: Maximum time to wait for handoff completion</li> </ul>"},{"location":"handoffs/#handoff-types","title":"Handoff Types","text":""},{"location":"handoffs/#1-direct-handoff","title":"1. Direct Handoff","text":"<p>Simple delegation to another agent:</p> <pre><code>const result = await Runner.run(mainAgent, \"Task\", {\n  handoff: mathAgent\n});\n</code></pre>"},{"location":"handoffs/#2-conditional-handoff","title":"2. Conditional Handoff","text":"<p>Handoff based on conditions:</p> <pre><code>const mainAgent = new Agent({\n  name: \"Coordinator\",\n  instructions: \"Delegate tasks based on their nature\",\n  handoffs: [mathAgent, codingAgent],\n  handoffRules: {\n    mathAgent: (input) =&gt; input.includes(\"solve\") || input.includes(\"calculate\"),\n    codingAgent: (input) =&gt; input.includes(\"code\") || input.includes(\"program\")\n  }\n});\n</code></pre>"},{"location":"handoffs/#3-chain-handoff","title":"3. Chain Handoff","text":"<p>Multiple agents working in sequence:</p> <pre><code>const result = await Runner.run(mainAgent, \"Task\", {\n  handoffChain: [mathAgent, codingAgent]\n});\n</code></pre>"},{"location":"handoffs/#best-practices","title":"Best Practices","text":"<ol> <li>Clear Instructions: Each agent should have clear instructions about its role</li> <li>Proper Delegation: Only delegate when necessary</li> <li>Error Handling: Handle handoff failures gracefully</li> <li>Timeout Management: Set appropriate timeouts for handoffs</li> <li>Monitoring: Track handoff performance and success rates</li> </ol>"},{"location":"handoffs/#advanced-features","title":"Advanced Features","text":""},{"location":"handoffs/#handoff-filters","title":"Handoff Filters","text":"<p>Filter when handoffs should occur:</p> <pre><code>const mainAgent = new Agent({\n  name: \"Coordinator\",\n  instructions: \"Delegate tasks based on their nature\",\n  handoffs: [mathAgent, codingAgent],\n  handoffFilters: {\n    mathAgent: (input) =&gt; {\n      return input.includes(\"solve\") || input.includes(\"calculate\");\n    },\n    codingAgent: (input) =&gt; {\n      return input.includes(\"code\") || input.includes(\"program\");\n    }\n  }\n});\n</code></pre>"},{"location":"handoffs/#handoff-context","title":"Handoff Context","text":"<p>Pass context between agents:</p> <pre><code>const result = await Runner.run(mainAgent, \"Task\", {\n  handoff: mathAgent,\n  context: {\n    previousSteps: [\"Step 1\", \"Step 2\"],\n    userPreferences: { precision: \"high\" }\n  }\n});\n</code></pre>"},{"location":"handoffs/#handoff-monitoring","title":"Handoff Monitoring","text":"<p>Monitor handoff performance:</p> <pre><code>const result = await Runner.run(mainAgent, \"Task\", {\n  handoff: mathAgent,\n  onHandoffStart: (agent) =&gt; {\n    console.log(`Handoff started to ${agent.name}`);\n  },\n  onHandoffComplete: (agent, result) =&gt; {\n    console.log(`Handoff completed to ${agent.name}`);\n  }\n});\n</code></pre>"},{"location":"handoffs/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Agents in detail</li> <li>Explore Tools for agent capabilities</li> <li>Set up Tracing for debugging</li> <li>Read about Guardrails for input validation </li> </ul>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#create-a-project","title":"Create a project","text":"<p>You'll only need to do this once.</p> <pre><code>mkdir my_project\ncd my_project\nnpm init -y\n</code></pre>"},{"location":"quickstart/#install-the-agents-sdk","title":"Install the Agents SDK","text":"<pre><code>npm install openai-agents-js\n</code></pre>"},{"location":"quickstart/#set-an-openai-api-key","title":"Set an OpenAI API key","text":"<p>If you don't have one, follow these instructions to create an OpenAI API key.</p> <pre><code>export OPENAI_API_KEY=sk-...\n</code></pre>"},{"location":"quickstart/#create-your-first-agent","title":"Create your first agent","text":"<p>Agents are defined with instructions, a name, and optional config (such as <code>modelConfig</code>)</p> <pre><code>import { Agent } from 'openai-agents-js';\n\nconst agent = new Agent({\n  name: \"Math Tutor\",\n  instructions: \"You provide help with math problems. Explain your reasoning at each step and include examples\",\n});\n</code></pre>"},{"location":"quickstart/#add-a-few-more-agents","title":"Add a few more agents","text":"<p>Additional agents can be defined in the same way. <code>handoff_description</code> provides additional context for determining handoff routing</p> <pre><code>import { Agent } from 'openai-agents-js';\n\nconst historyTutorAgent = new Agent({\n  name: \"History Tutor\",\n  handoff_description: \"Specialist agent for historical questions\",\n  instructions: \"You provide assistance with historical queries. Explain important events and context clearly.\",\n});\n\nconst mathTutorAgent = new Agent({\n  name: \"Math Tutor\",\n  handoff_description: \"Specialist agent for math questions\",\n  instructions: \"You provide help with math problems. Explain your reasoning at each step and include examples\",\n});\n</code></pre>"},{"location":"quickstart/#define-your-handoffs","title":"Define your handoffs","text":"<p>On each agent, you can define an inventory of outgoing handoff options that the agent can choose from to decide how to make progress on their task.</p> <pre><code>const triageAgent = new Agent({\n  name: \"Triage Agent\",\n  instructions: \"You determine which agent to use based on the user's homework question\",\n  handoffs: [historyTutorAgent, mathTutorAgent]\n});\n</code></pre>"},{"location":"quickstart/#run-the-agent-orchestration","title":"Run the agent orchestration","text":"<p>Let's check that the workflow runs and the triage agent correctly routes between the two specialist agents.</p> <pre><code>import { Runner } from 'openai-agents-js';\n\nasync function main() {\n  const result = await Runner.run(triageAgent, \"What is the capital of France?\");\n  console.log(result.finalOutput);\n}\n\nmain();\n</code></pre>"},{"location":"quickstart/#add-a-guardrail","title":"Add a guardrail","text":"<p>You can define custom guardrails to run on the input or output.</p> <pre><code>import { z } from 'zod';\nimport { \n  Agent, \n  Runner, \n  GuardrailFunctionOutput, \n  AgentOutputSchema,\n  RunContextWrapper,\n  TResponseInputItem \n} from 'openai-agents-js';\n\nconst HomeworkOutputSchema = z.object({\n  isHomework: z.boolean(),\n  reasoning: z.string(),\n});\n\nconst guardrailAgent = new Agent({\n  name: \"Guardrail check\",\n  instructions: \"Check if the user is asking about homework.\",\n  output_type: new AgentOutputSchema(HomeworkOutputSchema),\n});\n\nasync function homeworkGuardrail(\n  ctx: RunContextWrapper&lt;any&gt;, \n  agent: Agent&lt;any&gt;, \n  input: string | TResponseInputItem[]\n) {\n  const result = await Runner.run(guardrailAgent, input, { context: ctx.context });\n  const finalOutput = result.finalOutputAs(HomeworkOutputSchema);\n  console.log(finalOutput);\n  return new GuardrailFunctionOutput({\n    output_info: finalOutput,\n    tripwire_triggered: !finalOutput.isHomework,\n  });\n}\n</code></pre>"},{"location":"quickstart/#put-it-all-together","title":"Put it all together","text":"<p>Let's put it all together and run the entire workflow, using handoffs and the input guardrail.</p> <pre><code>import { z } from 'zod';\nimport { \n  Agent, \n  Runner, \n  GuardrailFunctionOutput, \n  AgentOutputSchema,\n  InputGuardrail,\n  RunContextWrapper,\n  TResponseInputItem \n} from 'openai-agents-js';\n\nconst HomeworkOutputSchema = z.object({\n  isHomework: z.boolean(),\n  reasoning: z.string(),\n});\n\nconst guardrailAgent = new Agent({\n  name: \"Guardrail check\",\n  instructions: \"Check if the user is asking about homework.\",\n  output_type: new AgentOutputSchema(HomeworkOutputSchema),\n});\n\nconst mathTutorAgent = new Agent({\n  name: \"Math Tutor\",\n  handoff_description: \"Specialist agent for math questions\",\n  instructions: \"You provide help with math problems. Explain your reasoning at each step and include examples\",\n});\n\nconst historyTutorAgent = new Agent({\n  name: \"History Tutor\",\n  handoff_description: \"Specialist agent for historical questions\",\n  instructions: \"You provide assistance with historical queries. Explain important events and context clearly.\",\n});\n\nasync function homeworkGuardrail(\n  ctx: RunContextWrapper&lt;any&gt;, \n  agent: Agent&lt;any&gt;, \n  input: string | TResponseInputItem[]\n) {\n  const result = await Runner.run(guardrailAgent, input, { context: ctx.context });\n  const finalOutput = result.finalOutputAs(HomeworkOutputSchema);\n  console.log(finalOutput);\n  return new GuardrailFunctionOutput({\n    output_info: finalOutput,\n    tripwire_triggered: !finalOutput.isHomework,\n  });\n}\n\nconst triageAgent = new Agent({\n  name: \"Triage Agent\",\n  instructions: \"You determine which agent to use based on the user's homework question\",\n  handoffs: [historyTutorAgent, mathTutorAgent],\n  input_guardrails: [new InputGuardrail(homeworkGuardrail)],\n});\n\nasync function main() {\n  const result1 = await Runner.run(triageAgent, \"who was the first president of the united states?\");\n  console.log(result1.finalOutput);\n\n  const result2 = await Runner.run(triageAgent, \"what is life\");\n  console.log(result2.finalOutput);\n}\n\nmain();\n</code></pre>"},{"location":"quickstart/#view-your-traces","title":"View your traces","text":"<p>To review what happened during your agent run, navigate to the Trace viewer in the OpenAI Dashboard to view traces of your agent runs.</p>"},{"location":"quickstart/#next-steps","title":"Next steps","text":"<p>Learn how to build more complex agentic flows:</p> <ul> <li>Learn about how to configure Agents.</li> <li>Learn about running agents.</li> <li>Learn about tools, guardrails and models. </li> </ul>"},{"location":"tools/","title":"Tools","text":"<p>Tools let agents take actions: things like fetching data, running code, calling external APIs, and even using a computer. There are three classes of tools in the Agent SDK:</p> <ul> <li>Hosted tools: these run on LLM servers alongside the AI models. OpenAI offers retrieval, web search and computer use as hosted tools.</li> <li>Function calling: these allow you to use any JavaScript/TypeScript function as a tool.</li> <li>Agents as tools: this allows you to use an agent as a tool, allowing Agents to call other agents without handing off to them.</li> </ul>"},{"location":"tools/#hosted-tools","title":"Hosted tools","text":"<p>OpenAI offers a few built-in tools when using the <code>OpenAIResponsesModel</code>:</p> <ul> <li>The <code>WebSearchTool</code> lets an agent search the web.</li> <li>The <code>FileSearchTool</code> allows retrieving information from your OpenAI Vector Stores.</li> <li>The <code>ComputerTool</code> allows automating computer use tasks.</li> </ul> <pre><code>import { Agent, FileSearchTool, Runner, WebSearchTool } from 'openai-agents-js';\n\nconst agent = new Agent({\n  name: \"Assistant\",\n  tools: [\n    new WebSearchTool(),\n    new FileSearchTool({\n      maxNumResults: 3,\n      vectorStoreIds: [\"VECTOR_STORE_ID\"],\n    }),\n  ],\n});\n\nasync function main() {\n  const result = await Runner.run(agent, \"Which coffee shop should I go to, taking into account my preferences and the weather today in SF?\");\n  console.log(result.finalOutput);\n}\n\nmain();\n</code></pre>"},{"location":"tools/#function-tools","title":"Function tools","text":"<p>You can use any JavaScript/TypeScript function as a tool. The Agents SDK will setup the tool automatically:</p> <ul> <li>The name of the tool will be the name of the function (or you can provide a name)</li> <li>Tool description will be taken from the JSDoc comments of the function (or you can provide a description)</li> <li>The schema for the function inputs is automatically created from the function's arguments using Zod</li> <li>Descriptions for each input are taken from the JSDoc comments of the function, unless disabled</li> </ul> <p>We use TypeScript's type system and Zod for schema creation and validation.</p> <pre><code>import { z } from 'zod';\nimport { Agent, FunctionTool, Runner } from 'openai-agents-js';\n\n// Define the schema for the weather data\nconst WeatherSchema = z.object({\n  city: z.string(),\n  temperatureRange: z.string(),\n  conditions: z.string(),\n});\n\n// Create a function tool\nconst getWeather = new FunctionTool({\n  name: 'get_weather',\n  description: 'Get the current weather for a city',\n  on_invoke_tool: async ({ context, input }) =&gt; {\n    const parsedInput = JSON.parse(input);\n    return {\n      city: parsedInput.city,\n      temperatureRange: '14-20C',\n      conditions: 'Sunny with wind.',\n    };\n  },\n  params_json_schema: {\n    type: 'object',\n    properties: {\n      city: {\n        type: 'string',\n        description: 'The city to get weather for',\n      },\n    },\n    required: ['city'],\n  },\n  strict_json_schema: false,\n});\n\n// Create an agent with the tool\nconst agent = new Agent({\n  name: 'Weather Assistant',\n  instructions: 'You are a helpful weather assistant.',\n  tools: [getWeather],\n});\n\nasync function main() {\n  const result = await Runner.run(agent, \"What's the weather in Tokyo?\");\n  console.log(result.finalOutput);\n  // The weather in Tokyo is sunny.\n}\n\nmain();\n</code></pre>"},{"location":"tools/#custom-function-tools","title":"Custom function tools","text":"<p>Sometimes, you don't want to use a JavaScript/TypeScript function as a tool. You can directly create a <code>FunctionTool</code> if you prefer. You'll need to provide:</p> <ul> <li><code>name</code></li> <li><code>description</code></li> <li><code>params_json_schema</code>, which is the JSON schema for the arguments</li> <li><code>on_invoke_tool</code>, which is an async function that receives the context and the arguments as a JSON string, and must return the tool output as a string.</li> </ul> <pre><code>import { z } from 'zod';\nimport { FunctionTool } from 'openai-agents-js';\n\n// Define the schema for user data\nconst UserSchema = z.object({\n  username: z.string(),\n  age: z.number(),\n});\n\n// Create a custom function tool\nconst processUser = new FunctionTool({\n  name: 'process_user',\n  description: 'Processes extracted user data',\n  params_json_schema: UserSchema,\n  on_invoke_tool: async ({ context, input }) =&gt; {\n    const parsed = UserSchema.parse(JSON.parse(input));\n    return `${parsed.username} is ${parsed.age} years old`;\n  },\n});\n</code></pre>"},{"location":"tools/#agents-as-tools","title":"Agents as tools","text":"<p>In some workflows, you may want a central agent to orchestrate a network of specialized agents, instead of handing off control. You can do this by modeling agents as tools.</p> <pre><code>import { Agent, Runner } from 'openai-agents-js';\n\nconst spanishAgent = new Agent({\n  name: \"Spanish agent\",\n  instructions: \"You translate the user's message to Spanish\",\n});\n\nconst frenchAgent = new Agent({\n  name: \"French agent\",\n  instructions: \"You translate the user's message to French\",\n});\n\nconst orchestratorAgent = new Agent({\n  name: \"orchestrator_agent\",\n  instructions: \"You are a translation agent. You use the tools given to you to translate. If asked for multiple translations, you call the relevant tools.\",\n  tools: [\n    spanishAgent.asTool({\n      toolName: \"translate_to_spanish\",\n      toolDescription: \"Translate the user's message to Spanish\",\n    }),\n    frenchAgent.asTool({\n      toolName: \"translate_to_french\",\n      toolDescription: \"Translate the user's message to French\",\n    }),\n  ],\n});\n\nasync function main() {\n  const result = await Runner.run(orchestratorAgent, \"Say 'Hello, how are you?' in Spanish.\");\n  console.log(result.finalOutput);\n}\n\nmain();\n</code></pre>"},{"location":"tools/#customizing-tool-agents","title":"Customizing tool-agents","text":"<p>The <code>agent.asTool</code> function is a convenience method to make it easy to turn an agent into a tool. It doesn't support all configuration though; for example, you can't set <code>maxTurns</code>. For advanced use cases, use <code>Runner.run</code> directly in your tool implementation:</p> <pre><code>import { Agent, FunctionTool, Runner } from 'openai-agents-js';\n\nconst runMyAgent = new FunctionTool({\n  name: 'run_my_agent',\n  description: 'A tool that runs the agent with custom configs',\n  on_invoke_tool: async ({ context, input }) =&gt; {\n    const agent = new Agent({\n      name: \"My agent\",\n      instructions: \"...\",\n    });\n\n    const result = await Runner.run(\n      agent,\n      input,\n      {\n        maxTurns: 5,\n        // ... other run config options\n      }\n    );\n\n    return result.finalOutput;\n  },\n});\n</code></pre>"},{"location":"tools/#handling-errors-in-function-tools","title":"Handling errors in function tools","text":"<p>When you create a function tool, you can handle errors in the <code>on_invoke_tool</code> function. The SDK provides several error types:</p> <ul> <li><code>ModelBehaviorError</code>: If the model produced invalid JSON</li> <li><code>UserError</code>: If your code crashed</li> <li><code>ToolError</code>: For general tool-related errors</li> </ul> <p>You can catch and handle these errors in your <code>on_invoke_tool</code> implementation:</p> <pre><code>import { FunctionTool, ModelBehaviorError, UserError } from 'openai-agents-js';\n\nconst tool = new FunctionTool({\n  name: 'my_tool',\n  description: 'A tool that handles errors gracefully',\n  on_invoke_tool: async ({ context, input }) =&gt; {\n    try {\n      // Your tool implementation\n      return \"Success!\";\n    } catch (error) {\n      if (error instanceof ModelBehaviorError) {\n        return \"The model provided invalid input. Please try again.\";\n      }\n      if (error instanceof UserError) {\n        return \"An error occurred while processing your request.\";\n      }\n      throw error; // Re-throw unexpected errors\n    }\n  },\n});\n</code></pre>"},{"location":"tracing/","title":"Tracing","text":"<p>Tracing helps you monitor, debug, and analyze your agents' behavior. It provides detailed insights into how agents make decisions, use tools, and handle handoffs.</p>"},{"location":"tracing/#basic-tracing","title":"Basic Tracing","text":"<pre><code>import { Agent, Runner, Tracer } from 'openai-agents';\n\n// Create a tracer\nconst tracer = new Tracer({\n  name: \"my-tracer\",\n  level: \"debug\"\n});\n\n// Create an agent with tracing enabled\nconst agent = new Agent({\n  name: \"TracedAgent\",\n  instructions: \"You are a helpful assistant\",\n  tracer: tracer\n});\n\n// Run the agent with tracing\nconst result = await Runner.run(agent, \"What is the weather?\", {\n  trace: true\n});\n</code></pre>"},{"location":"tracing/#trace-levels","title":"Trace Levels","text":"<ul> <li><code>debug</code>: Detailed information for debugging</li> <li><code>info</code>: General operational information</li> <li><code>warn</code>: Warning messages</li> <li><code>error</code>: Error messages</li> </ul>"},{"location":"tracing/#trace-types","title":"Trace Types","text":""},{"location":"tracing/#1-agent-traces","title":"1. Agent Traces","text":"<p>Track agent behavior and decisions:</p> <pre><code>const tracer = new Tracer({\n  name: \"agent-tracer\",\n  level: \"debug\",\n  onAgentStart: (agent) =&gt; {\n    console.log(`Agent ${agent.name} started`);\n  },\n  onAgentEnd: (agent, result) =&gt; {\n    console.log(`Agent ${agent.name} completed`);\n  }\n});\n</code></pre>"},{"location":"tracing/#2-tool-traces","title":"2. Tool Traces","text":"<p>Monitor tool usage and performance:</p> <pre><code>const tracer = new Tracer({\n  name: \"tool-tracer\",\n  level: \"debug\",\n  onToolStart: (tool, args) =&gt; {\n    console.log(`Tool ${tool.name} called with args:`, args);\n  },\n  onToolEnd: (tool, result) =&gt; {\n    console.log(`Tool ${tool.name} completed with result:`, result);\n  }\n});\n</code></pre>"},{"location":"tracing/#3-handoff-traces","title":"3. Handoff Traces","text":"<p>Track agent handoffs:</p> <pre><code>const tracer = new Tracer({\n  name: \"handoff-tracer\",\n  level: \"debug\",\n  onHandoffStart: (fromAgent, toAgent) =&gt; {\n    console.log(`Handoff from ${fromAgent.name} to ${toAgent.name}`);\n  },\n  onHandoffEnd: (fromAgent, toAgent, result) =&gt; {\n    console.log(`Handoff completed from ${fromAgent.name} to ${toAgent.name}`);\n  }\n});\n</code></pre>"},{"location":"tracing/#trace-storage","title":"Trace Storage","text":""},{"location":"tracing/#1-console-storage","title":"1. Console Storage","text":"<p>Default storage that logs to console:</p> <pre><code>const tracer = new Tracer({\n  name: \"console-tracer\",\n  storage: \"console\"\n});\n</code></pre>"},{"location":"tracing/#2-file-storage","title":"2. File Storage","text":"<p>Store traces in files:</p> <pre><code>const tracer = new Tracer({\n  name: \"file-tracer\",\n  storage: {\n    type: \"file\",\n    path: \"./traces\"\n  }\n});\n</code></pre>"},{"location":"tracing/#3-custom-storage","title":"3. Custom Storage","text":"<p>Implement custom storage:</p> <pre><code>const tracer = new Tracer({\n  name: \"custom-tracer\",\n  storage: {\n    type: \"custom\",\n    save: async (trace) =&gt; {\n      // Custom storage implementation\n    }\n  }\n});\n</code></pre>"},{"location":"tracing/#advanced-features","title":"Advanced Features","text":""},{"location":"tracing/#trace-filtering","title":"Trace Filtering","text":"<p>Filter which traces to record:</p> <pre><code>const tracer = new Tracer({\n  name: \"filtered-tracer\",\n  filters: {\n    agents: [\"MathAgent\", \"CodeAgent\"],\n    tools: [\"calculator\", \"code_analyzer\"],\n    levels: [\"error\", \"warn\"]\n  }\n});\n</code></pre>"},{"location":"tracing/#trace-analysis","title":"Trace Analysis","text":"<p>Analyze trace data:</p> <pre><code>const analysis = await tracer.analyze({\n  timeRange: {\n    start: new Date(\"2024-01-01\"),\n    end: new Date()\n  },\n  metrics: [\"duration\", \"success_rate\", \"error_rate\"]\n});\n</code></pre>"},{"location":"tracing/#trace-visualization","title":"Trace Visualization","text":"<p>Visualize trace data:</p> <pre><code>const visualization = await tracer.visualize({\n  type: \"timeline\",\n  data: traces\n});\n</code></pre>"},{"location":"tracing/#best-practices","title":"Best Practices","text":"<ol> <li>Appropriate Level: Use the right trace level for your needs</li> <li>Storage Management: Regularly clean up old traces</li> <li>Performance Impact: Be mindful of tracing overhead</li> <li>Security: Don't log sensitive information</li> <li>Analysis: Regularly analyze traces for insights</li> </ol>"},{"location":"tracing/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Agents in detail</li> <li>Explore Tools for agent capabilities</li> <li>Understand Handoffs for complex workflows</li> <li>Read about Guardrails for input validation </li> </ul>"}]}